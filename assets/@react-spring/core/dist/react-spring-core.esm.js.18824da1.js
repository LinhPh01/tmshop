import{l as Q,m as oe,n as ue,i as o,u as re,o as Mt,a as w,f as ce,k as he,c as de,p as q,g as T,t as A,q as vt,s as nt,F as le,v as fe,e as L,w as it,x as W,j as ut,h as k,r as Bt,y as St,z as me,b as $t,A as Ct}from"../../shared/dist/react-spring-shared.esm.js.e4325886.js";import"../../../react/index.js.fa086085.js";import{g as lt,s as Lt,a as j,b as Pt,A as pe,c as At}from"../../animated/dist/react-spring-animated.esm.js.c753c843.js";import{r as R}from"../../rafz/dist/react-spring-rafz.esm.js.325c0a2b.js";import{r as E}from"../../../react/index.js_commonjs-module.8c7d3518.js";function M(){return M=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])}return t},M.apply(this,arguments)}function D(t,...e){return o.fun(t)?t(...e):t}const Y=(t,e)=>t===!0||!!(e&&t&&(o.fun(t)?t(e):A(t).includes(e))),Gt=(t,e)=>o.obj(t)?e&&t[e]:t,Ht=(t,e)=>t.default===!0?t[e]:t.default?t.default[e]:void 0,ge=t=>t,bt=(t,e=ge)=>{let s=_e;t.default&&t.default!==!0&&(t=t.default,s=Object.keys(t));const i={};for(const n of s){const a=e(t[n],n);o.und(a)||(i[n]=a)}return i},_e=["config","onProps","onStart","onChange","onPause","onResume","onRest"],ye={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function ve(t){const e={};let s=0;if(L(t,(i,n)=>{ye[n]||(e[n]=i,s++)}),s)return e}function Kt(t){const e=ve(t);if(e){const s={to:e};return L(t,(i,n)=>n in e||(s[n]=i)),s}return M({},t)}function X(t){return t=T(t),o.arr(t)?t.map(X):$t(t)?Q.createStringInterpolator({range:[0,1],output:[t,t]})(1):t}function Pe(t){for(const e in t)return!0;return!1}function ft(t){return o.fun(t)||o.arr(t)&&o.obj(t[0])}function be(t,e){var s;(s=t.ref)==null||s.delete(t),e==null||e.delete(t)}function we(t,e){if(e&&t.ref!==e){var s;(s=t.ref)==null||s.delete(t),e.add(t),t.ref=e}}const Ie={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}},at=1.70158,et=at*1.525,Ot=at+1,Rt=2*Math.PI/3,Vt=2*Math.PI/4.5,st=t=>t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375,Me={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>1-(1-t)*(1-t),easeInOutQuad:t=>t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2,easeInCubic:t=>t*t*t,easeOutCubic:t=>1-Math.pow(1-t,3),easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeInQuart:t=>t*t*t*t,easeOutQuart:t=>1-Math.pow(1-t,4),easeInOutQuart:t=>t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2,easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>1-Math.pow(1-t,5),easeInOutQuint:t=>t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2,easeInSine:t=>1-Math.cos(t*Math.PI/2),easeOutSine:t=>Math.sin(t*Math.PI/2),easeInOutSine:t=>-(Math.cos(Math.PI*t)-1)/2,easeInExpo:t=>t===0?0:Math.pow(2,10*t-10),easeOutExpo:t=>t===1?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>t===0?0:t===1?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2,easeInCirc:t=>1-Math.sqrt(1-Math.pow(t,2)),easeOutCirc:t=>Math.sqrt(1-Math.pow(t-1,2)),easeInOutCirc:t=>t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2,easeInBack:t=>Ot*t*t*t-at*t*t,easeOutBack:t=>1+Ot*Math.pow(t-1,3)+at*Math.pow(t-1,2),easeInOutBack:t=>t<.5?Math.pow(2*t,2)*((et+1)*2*t-et)/2:(Math.pow(2*t-2,2)*((et+1)*(t*2-2)+et)+2)/2,easeInElastic:t=>t===0?0:t===1?1:-Math.pow(2,10*t-10)*Math.sin((t*10-10.75)*Rt),easeOutElastic:t=>t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-.75)*Rt)+1,easeInOutElastic:t=>t===0?0:t===1?1:t<.5?-(Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*Vt))/2:Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*Vt)/2+1,easeInBounce:t=>1-st(1-t),easeOutBounce:st,easeInOutBounce:t=>t<.5?(1-st(1-2*t))/2:(1+st(2*t-1))/2},mt=M({},Ie.default,{mass:1,damping:1,easing:Me.linear,clamp:!1});class Se{constructor(){this.tension=void 0,this.friction=void 0,this.frequency=void 0,this.damping=void 0,this.mass=void 0,this.velocity=0,this.restVelocity=void 0,this.precision=void 0,this.progress=void 0,this.duration=void 0,this.easing=void 0,this.clamp=void 0,this.bounce=void 0,this.decay=void 0,this.round=void 0,Object.assign(this,mt)}}function Ce(t,e,s){s&&(s=M({},s),Tt(s,e),e=M({},s,e)),Tt(t,e),Object.assign(t,e);for(const h in mt)t[h]==null&&(t[h]=mt[h]);let{mass:i,frequency:n,damping:a}=t;return o.und(n)||(n<.01&&(n=.01),a<0&&(a=0),t.tension=Math.pow(2*Math.PI/n,2)*i,t.friction=4*Math.PI*a*i/n),t}function Tt(t,e){if(!o.und(e.decay))t.duration=void 0;else{const s=!o.und(e.tension)||!o.und(e.friction);(s||!o.und(e.frequency)||!o.und(e.damping)||!o.und(e.mass))&&(t.duration=void 0,t.decay=void 0),s&&(t.frequency=void 0)}}const Et=[];class Ae{constructor(){this.changed=!1,this.values=Et,this.toValues=null,this.fromValues=Et,this.to=void 0,this.from=void 0,this.config=new Se,this.immediate=!1}}function Jt(t,{key:e,props:s,defaultProps:i,state:n,actions:a}){return new Promise((h,p)=>{var u;let d,r,l=Y((u=s.cancel)!=null?u:i==null?void 0:i.cancel,e);if(l)y();else{o.und(s.pause)||(n.paused=Y(s.pause,e));let f=i==null?void 0:i.pause;f!==!0&&(f=n.paused||Y(f,e)),d=D(s.delay||0,e),f?(n.resumeQueue.add(b),a.pause()):(a.resume(),b())}function v(){n.resumeQueue.add(b),n.timeouts.delete(r),r.cancel(),d=r.time-R.now()}function b(){d>0&&!Q.skipAnimation?(n.delayed=!0,r=R.setTimeout(y,d),n.pauseQueue.add(v),n.timeouts.add(r)):y()}function y(){n.delayed&&(n.delayed=!1),n.pauseQueue.delete(v),n.timeouts.delete(r),t<=(n.cancelId||0)&&(l=!0);try{a.start(M({},s,{callId:t,cancel:l}),h)}catch(f){p(f)}}})}const wt=(t,e)=>e.length==1?e[0]:e.some(s=>s.cancelled)?$(t.get()):e.every(s=>s.noop)?Wt(t.get()):O(t.get(),e.every(s=>s.finished)),Wt=t=>({value:t,noop:!0,finished:!0,cancelled:!1}),O=(t,e,s=!1)=>({value:t,finished:e,cancelled:s}),$=t=>({value:t,cancelled:!0,finished:!1});function Yt(t,e,s,i){const{callId:n,parentId:a,onRest:h}=e,{asyncTo:p,promise:u}=s;return!a&&t===p&&!e.reset?u:s.promise=(async()=>{s.asyncId=n,s.asyncTo=t;const d=bt(e,(c,m)=>m==="onRest"?void 0:c);let r,l;const v=new Promise((c,m)=>(r=c,l=m)),b=c=>{const m=n<=(s.cancelId||0)&&$(i)||n!==s.asyncId&&O(i,!1);if(m)throw c.result=m,l(c),c},y=(c,m)=>{const g=new Ft,P=new qt;return(async()=>{if(Q.skipAnimation)throw Z(s),P.result=O(i,!1),l(P),P;b(g);const _=o.obj(c)?M({},c):M({},m,{to:c});_.parentId=n,L(d,(S,z)=>{o.und(_[z])&&(_[z]=S)});const I=await i.start(_);return b(g),s.paused&&await new Promise(S=>{s.resumeQueue.add(S)}),I})()};let f;if(Q.skipAnimation)return Z(s),O(i,!1);try{let c;o.arr(t)?c=(async m=>{for(const g of m)await y(g)})(t):c=Promise.resolve(t(y,i.stop.bind(i))),await Promise.all([c.then(r),v]),f=O(i.get(),!0,!1)}catch(c){if(c instanceof Ft)f=c.result;else if(c instanceof qt)f=c.result;else throw c}finally{n==s.asyncId&&(s.asyncId=a,s.asyncTo=a?p:void 0,s.promise=a?u:void 0)}return o.fun(h)&&R.batchedUpdates(()=>{h(f,i,i.item)}),f})()}function Z(t,e){it(t.timeouts,s=>s.cancel()),t.pauseQueue.clear(),t.resumeQueue.clear(),t.asyncId=t.asyncTo=t.promise=void 0,e&&(t.cancelId=e)}class Ft extends Error{constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."),this.result=void 0}}class qt extends Error{constructor(){super("SkipAnimationSignal"),this.result=void 0}}const pt=t=>t instanceof It;let Oe=1;class It extends le{constructor(...e){super(...e),this.id=Oe++,this.key=void 0,this._priority=0}get priority(){return this._priority}set priority(e){this._priority!=e&&(this._priority=e,this._onPriorityChange(e))}get(){const e=j(this);return e&&e.getValue()}to(...e){return Q.to(this,e)}interpolate(...e){return fe(),Q.to(this,e)}toJSON(){return this.get()}observerAdded(e){e==1&&this._attach()}observerRemoved(e){e==0&&this._detach()}_attach(){}_detach(){}_onChange(e,s=!1){nt(this,{type:"change",parent:this,value:e,idle:s})}_onPriorityChange(e){this.idle||vt.sort(this),nt(this,{type:"priority",parent:this,priority:e})}}const N=Symbol.for("SpringPhase"),Xt=1,gt=2,_t=4,ht=t=>(t[N]&Xt)>0,U=t=>(t[N]&gt)>0,H=t=>(t[N]&_t)>0,jt=(t,e)=>e?t[N]|=gt|Xt:t[N]&=~gt,Qt=(t,e)=>e?t[N]|=_t:t[N]&=~_t;class Re extends It{constructor(e,s){if(super(),this.key=void 0,this.animation=new Ae,this.queue=void 0,this.defaultProps={},this._state={paused:!1,delayed:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set},this._pendingCalls=new Set,this._lastCallId=0,this._lastToId=0,this._memoizedDuration=0,!o.und(e)||!o.und(s)){const i=o.obj(e)?M({},e):M({},s,{from:e});o.und(i.default)&&(i.default=!0),this.start(i)}}get idle(){return!(U(this)||this._state.asyncTo)||H(this)}get goal(){return T(this.animation.to)}get velocity(){const e=j(this);return e instanceof pe?e.lastVelocity||0:e.getPayload().map(s=>s.lastVelocity||0)}get hasAnimated(){return ht(this)}get isAnimating(){return U(this)}get isPaused(){return H(this)}get isDelayed(){return this._state.delayed}advance(e){let s=!0,i=!1;const n=this.animation;let{config:a,toValues:h}=n;const p=Pt(n.to);!p&&k(n.to)&&(h=A(T(n.to))),n.values.forEach((r,l)=>{if(r.done)return;const v=r.constructor==At?1:p?p[l].lastPosition:h[l];let b=n.immediate,y=v;if(!b){if(y=r.lastPosition,a.tension<=0){r.done=!0;return}let f=r.elapsedTime+=e;const c=n.fromValues[l],m=r.v0!=null?r.v0:r.v0=o.arr(a.velocity)?a.velocity[l]:a.velocity;let g;const P=a.precision||(c==v?.005:Math.min(1,Math.abs(v-c)*.001));if(o.und(a.duration))if(a.decay){const _=a.decay===!0?.998:a.decay,I=Math.exp(-(1-_)*f);y=c+m/(1-_)*(1-I),b=Math.abs(r.lastPosition-y)<=P,g=m*I}else{g=r.lastVelocity==null?m:r.lastVelocity;const _=a.restVelocity||P/10,I=a.clamp?0:a.bounce,S=!o.und(I),z=c==v?r.v0>0:c<v;let F,tt=!1;const C=1,G=Math.ceil(e/C);for(let V=0;V<G&&(F=Math.abs(g)>_,!(!F&&(b=Math.abs(v-y)<=P,b)));++V){S&&(tt=y==v||y>v==z,tt&&(g=-g*I,y=v));const B=-a.tension*1e-6*(y-v),ct=-a.friction*.001*g,ae=(B+ct)/a.mass;g=g+ae*C,y=y+g*C}}else{let _=1;a.duration>0&&(this._memoizedDuration!==a.duration&&(this._memoizedDuration=a.duration,r.durationProgress>0&&(r.elapsedTime=a.duration*r.durationProgress,f=r.elapsedTime+=e)),_=(a.progress||0)+f/this._memoizedDuration,_=_>1?1:_<0?0:_,r.durationProgress=_),y=c+a.easing(_)*(v-c),g=(y-r.lastPosition)/e,b=_==1}r.lastVelocity=g,Number.isNaN(y)&&(console.warn("Got NaN while animating:",this),b=!0)}p&&!p[l].done&&(b=!1),b?r.done=!0:s=!1,r.setValue(y,a.round)&&(i=!0)});const u=j(this),d=u.getValue();if(s){const r=T(n.to);(d!==r||i)&&!a.decay?(u.setValue(r),this._onChange(r)):i&&a.decay&&this._onChange(d),this._stop()}else i&&this._onChange(d)}set(e){return R.batchedUpdates(()=>{this._stop(),this._focus(e),this._set(e)}),this}pause(){this._update({pause:!0})}resume(){this._update({pause:!1})}finish(){if(U(this)){const{to:e,config:s}=this.animation;R.batchedUpdates(()=>{this._onStart(),s.decay||this._set(e,!1),this._stop()})}return this}update(e){return(this.queue||(this.queue=[])).push(e),this}start(e,s){let i;return o.und(e)?(i=this.queue||[],this.queue=[]):i=[o.obj(e)?e:M({},s,{to:e})],Promise.all(i.map(n=>this._update(n))).then(n=>wt(this,n))}stop(e){const{to:s}=this.animation;return this._focus(this.get()),Z(this._state,e&&this._lastCallId),R.batchedUpdates(()=>this._stop(s,e)),this}reset(){this._update({reset:!0})}eventObserved(e){e.type=="change"?this._start():e.type=="priority"&&(this.priority=e.priority+1)}_prepareNode(e){const s=this.key||"";let{to:i,from:n}=e;i=o.obj(i)?i[s]:i,(i==null||ft(i))&&(i=void 0),n=o.obj(n)?n[s]:n,n==null&&(n=void 0);const a={to:i,from:n};return ht(this)||(e.reverse&&([i,n]=[n,i]),n=T(n),o.und(n)?j(this)||this._set(i):this._set(n)),a}_update(e,s){let i=M({},e);const{key:n,defaultProps:a}=this;i.default&&Object.assign(a,bt(i,(u,d)=>/^on/.test(d)?Gt(u,n):u)),kt(this,i,"onProps"),J(this,"onProps",i,this);const h=this._prepareNode(i);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");const p=this._state;return Jt(++this._lastCallId,{key:n,props:i,defaultProps:a,state:p,actions:{pause:()=>{H(this)||(Qt(this,!0),W(p.pauseQueue),J(this,"onPause",O(this,K(this,this.animation.to)),this))},resume:()=>{H(this)&&(Qt(this,!1),U(this)&&this._resume(),W(p.resumeQueue),J(this,"onResume",O(this,K(this,this.animation.to)),this))},start:this._merge.bind(this,h)}}).then(u=>{if(i.loop&&u.finished&&!(s&&u.noop)){const d=Zt(i);if(d)return this._update(d,!0)}return u})}_merge(e,s,i){if(s.cancel)return this.stop(!0),i($(this));const n=!o.und(e.to),a=!o.und(e.from);if(n||a)if(s.callId>this._lastToId)this._lastToId=s.callId;else return i($(this));const{key:h,defaultProps:p,animation:u}=this,{to:d,from:r}=u;let{to:l=d,from:v=r}=e;a&&!n&&(!s.default||o.und(l))&&(l=v),s.reverse&&([l,v]=[v,l]);const b=!q(v,r);b&&(u.from=v),v=T(v);const y=!q(l,d);y&&this._focus(l);const f=ft(s.to),{config:c}=u,{decay:m,velocity:g}=c;(n||a)&&(c.velocity=0),s.config&&!f&&Ce(c,D(s.config,h),s.config!==p.config?D(p.config,h):void 0);let P=j(this);if(!P||o.und(l))return i(O(this,!0));const _=o.und(s.reset)?a&&!s.default:!o.und(v)&&Y(s.reset,h),I=_?v:this.get(),S=X(l),z=o.num(S)||o.arr(S)||$t(S),F=!f&&(!z||Y(p.immediate||s.immediate,h));if(y){const V=lt(l);if(V!==P.constructor)if(F)P=this._set(S);else throw Error(`Cannot animate between ${P.constructor.name} and ${V.name}, as the "to" prop suggests`)}const tt=P.constructor;let C=k(l),G=!1;if(!C){const V=_||!ht(this)&&b;(y||V)&&(G=q(X(I),S),C=!G),(!q(u.immediate,F)&&!F||!q(c.decay,m)||!q(c.velocity,g))&&(C=!0)}if(G&&U(this)&&(u.changed&&!_?C=!0:C||this._stop(d)),!f&&((C||k(d))&&(u.values=P.getPayload(),u.toValues=k(l)?null:tt==At?[1]:A(S)),u.immediate!=F&&(u.immediate=F,!F&&!_&&this._set(d)),C)){const{onRest:V}=u;w(Te,ct=>kt(this,s,ct));const B=O(this,K(this,d));W(this._pendingCalls,B),this._pendingCalls.add(i),u.changed&&R.batchedUpdates(()=>{u.changed=!_,V==null||V(B,this),_?D(p.onRest,B):u.onStart==null||u.onStart(B,this)})}_&&this._set(I),f?i(Yt(s.to,s,this._state,this)):C?this._start():U(this)&&!y?this._pendingCalls.add(i):i(Wt(I))}_focus(e){const s=this.animation;e!==s.to&&(Ct(this)&&this._detach(),s.to=e,Ct(this)&&this._attach())}_attach(){let e=0;const{to:s}=this.animation;k(s)&&(ut(s,this),pt(s)&&(e=s.priority+1)),this.priority=e}_detach(){const{to:e}=this.animation;k(e)&&Bt(e,this)}_set(e,s=!0){const i=T(e);if(!o.und(i)){const n=j(this);if(!n||!q(i,n.getValue())){const a=lt(i);!n||n.constructor!=a?Lt(this,a.create(i)):n.setValue(i),n&&R.batchedUpdates(()=>{this._onChange(i,s)})}}return j(this)}_onStart(){const e=this.animation;e.changed||(e.changed=!0,J(this,"onStart",O(this,K(this,e.to)),this))}_onChange(e,s){s||(this._onStart(),D(this.animation.onChange,e,this)),D(this.defaultProps.onChange,e,this),super._onChange(e,s)}_start(){const e=this.animation;j(this).reset(T(e.to)),e.immediate||(e.fromValues=e.values.map(s=>s.lastPosition)),U(this)||(jt(this,!0),H(this)||this._resume())}_resume(){Q.skipAnimation?this.finish():vt.start(this)}_stop(e,s){if(U(this)){jt(this,!1);const i=this.animation;w(i.values,a=>{a.done=!0}),i.toValues&&(i.onChange=i.onPause=i.onResume=void 0),nt(this,{type:"idle",parent:this});const n=s?$(this.get()):O(this.get(),K(this,e!=null?e:i.to));W(this._pendingCalls,n),i.changed&&(i.changed=!1,J(this,"onRest",n,this))}}}function K(t,e){const s=X(e),i=X(t.get());return q(i,s)}function Zt(t,e=t.loop,s=t.to){let i=D(e);if(i){const n=i!==!0&&Kt(i),a=(n||t).reverse,h=!n||n.reset;return x(M({},t,{loop:e,default:!1,pause:void 0,to:!a||ft(s)?s:void 0,from:h?t.from:void 0,reset:h},n))}}function x(t){const{to:e,from:s}=t=Kt(t),i=new Set;return o.obj(e)&&Ut(e,i),o.obj(s)&&Ut(s,i),t.keys=i.size?Array.from(i):null,t}function Ve(t){const e=x(t);return o.und(e.default)&&(e.default=bt(e)),e}function Ut(t,e){L(t,(s,i)=>s!=null&&e.add(i))}const Te=["onStart","onRest","onChange","onPause","onResume"];function kt(t,e,s){t.animation[s]=e[s]!==Ht(e,s)?Gt(e[s],t.key):void 0}function J(t,e,...s){var i,n,a,h;(i=(n=t.animation)[e])==null||i.call(n,...s),(a=(h=t.defaultProps)[e])==null||a.call(h,...s)}const Ee=["onStart","onChange","onRest"];let Fe=1;class qe{constructor(e,s){this.id=Fe++,this.springs={},this.queue=[],this.ref=void 0,this._flush=void 0,this._initialProps=void 0,this._lastAsyncId=0,this._active=new Set,this._changed=new Set,this._started=!1,this._item=void 0,this._state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set},this._events={onStart:new Map,onChange:new Map,onRest:new Map},this._onFrame=this._onFrame.bind(this),s&&(this._flush=s),e&&this.start(M({default:!0},e))}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every(e=>e.idle&&!e.isDelayed&&!e.isPaused)}get item(){return this._item}set item(e){this._item=e}get(){const e={};return this.each((s,i)=>e[i]=s.get()),e}set(e){for(const s in e){const i=e[s];o.und(i)||this.springs[s].set(i)}}update(e){return e&&this.queue.push(x(e)),this}start(e){let{queue:s}=this;return e?s=A(e).map(x):this.queue=[],this._flush?this._flush(this,s):(ie(this,s),yt(this,s))}stop(e,s){if(e!==!!e&&(s=e),s){const i=this.springs;w(A(s),n=>i[n].stop(!!e))}else Z(this._state,this._lastAsyncId),this.each(i=>i.stop(!!e));return this}pause(e){if(o.und(e))this.start({pause:!0});else{const s=this.springs;w(A(e),i=>s[i].pause())}return this}resume(e){if(o.und(e))this.start({pause:!1});else{const s=this.springs;w(A(e),i=>s[i].resume())}return this}each(e){L(this.springs,e)}_onFrame(){const{onStart:e,onChange:s,onRest:i}=this._events,n=this._active.size>0,a=this._changed.size>0;(n&&!this._started||a&&!this._started)&&(this._started=!0,it(e,([u,d])=>{d.value=this.get(),u(d,this,this._item)}));const h=!n&&this._started,p=a||h&&i.size?this.get():null;a&&s.size&&it(s,([u,d])=>{d.value=p,u(d,this,this._item)}),h&&(this._started=!1,it(i,([u,d])=>{d.value=p,u(d,this,this._item)}))}eventObserved(e){if(e.type=="change")this._changed.add(e.parent),e.idle||this._active.add(e.parent);else if(e.type=="idle")this._active.delete(e.parent);else return;R.onFrame(this._onFrame)}}function yt(t,e){return Promise.all(e.map(s=>xt(t,s))).then(s=>wt(t,s))}async function xt(t,e,s){const{keys:i,to:n,from:a,loop:h,onRest:p,onResolve:u}=e,d=o.obj(e.default)&&e.default;h&&(e.loop=!1),n===!1&&(e.to=null),a===!1&&(e.from=null);const r=o.arr(n)||o.fun(n)?n:void 0;r?(e.to=void 0,e.onRest=void 0,d&&(d.onRest=void 0)):w(Ee,f=>{const c=e[f];if(o.fun(c)){const m=t._events[f];e[f]=({finished:g,cancelled:P})=>{const _=m.get(c);_?(g||(_.finished=!1),P&&(_.cancelled=!0)):m.set(c,{value:null,finished:g||!1,cancelled:P||!1})},d&&(d[f]=e[f])}});const l=t._state;e.pause===!l.paused?(l.paused=e.pause,W(e.pause?l.pauseQueue:l.resumeQueue)):l.paused&&(e.pause=!0);const v=(i||Object.keys(t.springs)).map(f=>t.springs[f].start(e)),b=e.cancel===!0||Ht(e,"cancel")===!0;(r||b&&l.asyncId)&&v.push(Jt(++t._lastAsyncId,{props:e,state:l,actions:{pause:St,resume:St,start(f,c){b?(Z(l,t._lastAsyncId),c($(t))):(f.onRest=p,c(Yt(r,f,l,t)))}}})),l.paused&&await new Promise(f=>{l.resumeQueue.add(f)});const y=wt(t,await Promise.all(v));if(h&&y.finished&&!(s&&y.noop)){const f=Zt(e,h,n);if(f)return ie(t,[f]),xt(t,f,!0)}return u&&R.batchedUpdates(()=>u(y,t,t.item)),y}function Dt(t,e){const s=M({},t.springs);return e&&w(A(e),i=>{o.und(i.keys)&&(i=x(i)),o.obj(i.to)||(i=M({},i,{to:void 0})),se(s,i,n=>ee(n))}),te(t,s),s}function te(t,e){L(e,(s,i)=>{t.springs[i]||(t.springs[i]=s,ut(s,t))})}function ee(t,e){const s=new Re;return s.key=t,e&&ut(s,e),s}function se(t,e,s){e.keys&&w(e.keys,i=>{(t[i]||(t[i]=s(i)))._prepareNode(e)})}function ie(t,e){w(e,s=>{se(t.springs,s,i=>ee(i,t))})}function je(t,e){if(t==null)return{};var s={},i=Object.keys(t),n,a;for(a=0;a<i.length;a++)n=i[a],!(e.indexOf(n)>=0)&&(s[n]=t[n]);return s}const Qe=["children"],rt=t=>{let{children:e}=t,s=je(t,Qe);const i=E.exports.useContext(ot),n=s.pause||!!i.pause,a=s.immediate||!!i.immediate;s=ue(()=>({pause:n,immediate:a}),[n,a]);const{Provider:h}=ot;return E.exports.createElement(h,{value:s},e)},ot=Ue(rt,{});rt.Provider=ot.Provider;rt.Consumer=ot.Consumer;function Ue(t,e){return Object.assign(t,E.exports.createContext(e)),t.Provider._context=t,t.Consumer._context=t,t}const ke=()=>{const t=[],e=function(n){me();const a=[];return w(t,(h,p)=>{if(o.und(n))a.push(h.start());else{const u=s(n,h,p);u&&a.push(h.start(u))}}),a};e.current=t,e.add=function(i){t.includes(i)||t.push(i)},e.delete=function(i){const n=t.indexOf(i);~n&&t.splice(n,1)},e.pause=function(){return w(t,i=>i.pause(...arguments)),this},e.resume=function(){return w(t,i=>i.resume(...arguments)),this},e.set=function(i){w(t,n=>n.set(i))},e.start=function(i){const n=[];return w(t,(a,h)=>{if(o.und(i))n.push(a.start());else{const p=this._getProps(i,a,h);p&&n.push(a.start(p))}}),n},e.stop=function(){return w(t,i=>i.stop(...arguments)),this},e.update=function(i){return w(t,(n,a)=>n.update(this._getProps(i,n,a))),this};const s=function(n,a,h){return o.fun(n)?n(h,a):n};return e._getProps=s,e};function De(t,e,s){const i=o.fun(e)&&e;i&&!s&&(s=[]);const n=E.exports.useMemo(()=>i||arguments.length==3?ke():void 0,[]),a=E.exports.useRef(0),h=re(),p=E.exports.useMemo(()=>({ctrls:[],queue:[],flush(m,g){const P=Dt(m,g);return a.current>0&&!p.queue.length&&!Object.keys(P).some(I=>!m.springs[I])?yt(m,g):new Promise(I=>{te(m,P),p.queue.push(()=>{I(yt(m,g))}),h()})}}),[]),u=E.exports.useRef([...p.ctrls]),d=[],r=Mt(t)||0;E.exports.useMemo(()=>{w(u.current.slice(t,r),m=>{be(m,n),m.stop(!0)}),u.current.length=t,l(r,t)},[t]),E.exports.useMemo(()=>{l(0,Math.min(r,t))},s);function l(m,g){for(let P=m;P<g;P++){const _=u.current[P]||(u.current[P]=new qe(null,p.flush)),I=i?i(P,_):e[P];I&&(d[P]=Ve(I))}}const v=u.current.map((m,g)=>Dt(m,d[g])),b=E.exports.useContext(rt),y=Mt(b),f=b!==y&&Pe(b);ce(()=>{a.current++,p.ctrls=u.current;const{queue:m}=p;m.length&&(p.queue=[],w(m,g=>g())),w(u.current,(g,P)=>{n==null||n.add(g),f&&g.start({default:b});const _=d[P];_&&(we(g,_.ref),g.ref?g.queue.push(_):g.start(_))})}),he(()=>()=>{w(p.ctrls,m=>m.stop(!0))});const c=v.map(m=>M({},m));return n?[c,n]:c}function He(t,e){const s=o.fun(t),[[i],n]=De(1,s?t:[t],s?e||[]:e);return s||arguments.length==2?[i,n]:i}let Nt;(function(t){t.MOUNT="mount",t.ENTER="enter",t.UPDATE="update",t.LEAVE="leave"})(Nt||(Nt={}));class ne extends It{constructor(e,s){super(),this.key=void 0,this.idle=!0,this.calc=void 0,this._active=new Set,this.source=e,this.calc=de(...s);const i=this._get(),n=lt(i);Lt(this,n.create(i))}advance(e){const s=this._get(),i=this.get();q(s,i)||(j(this).setValue(s),this._onChange(s,this.idle)),!this.idle&&zt(this._active)&&dt(this)}_get(){const e=o.arr(this.source)?this.source.map(T):A(T(this.source));return this.calc(...e)}_start(){this.idle&&!zt(this._active)&&(this.idle=!1,w(Pt(this),e=>{e.done=!1}),Q.skipAnimation?(R.batchedUpdates(()=>this.advance()),dt(this)):vt.start(this))}_attach(){let e=1;w(A(this.source),s=>{k(s)&&ut(s,this),pt(s)&&(s.idle||this._active.add(s),e=Math.max(e,s.priority+1))}),this.priority=e,this._start()}_detach(){w(A(this.source),e=>{k(e)&&Bt(e,this)}),this._active.clear(),dt(this)}eventObserved(e){e.type=="change"?e.idle?this.advance():(this._active.add(e.parent),this._start()):e.type=="idle"?this._active.delete(e.parent):e.type=="priority"&&(this.priority=A(this.source).reduce((s,i)=>Math.max(s,(pt(i)?i.priority:0)+1),0))}}function Ne(t){return t.idle!==!1}function zt(t){return!t.size||Array.from(t).every(Ne)}function dt(t){t.idle||(t.idle=!0,w(Pt(t),e=>{e.done=!0}),nt(t,{type:"idle",parent:t}))}const Ke=(t,...e)=>new ne(t,e);Q.assign({createStringInterpolator:oe,to:(t,e)=>new ne(t,e)});export{He as a,Ke as t,De as u};
